# 9.20. 範圍函式及運算子

See [Section 8.17](https://www.postgresql.org/docs/current/rangetypes.html) for an overview of range types.

[Table 9.55](https://www.postgresql.org/docs/current/functions-range.html#RANGE-OPERATORS-TABLE) shows the specialized operators available for range types. [Table 9.56](https://www.postgresql.org/docs/current/functions-range.html#MULTIRANGE-OPERATORS-TABLE) shows the specialized operators available for multirange types. In addition to those, the usual comparison operators shown in [Table 9.1](https://www.postgresql.org/docs/current/functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE) are available for range and multirange types. The comparison operators order first by the range lower bounds, and only if those are equal do they compare the upper bounds. The multirange operators compare each range until one is unequal. This does not usually result in a useful overall ordering, but the operators are provided to allow unique indexes to be constructed on ranges.

#### **Table 9.55. Range Operators**

| <p>Operator</p><p>Description</p><p>Example(s)</p>                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p><code>anyrange</code> <code>@></code> <code>anyrange</code> → <code>boolean</code></p><p>Does the first range contain the second?</p><p><code>int4range(2,4) @> int4range(2,3)</code> → <code>t</code></p>                                                                                                                         |
| <p><code>anyrange</code> <code>@></code> <code>anyelement</code> → <code>boolean</code></p><p>Does the range contain the element?</p><p><code>'[2011-01-01,2011-03-01)'::tsrange @> '2011-01-10'::timestamp</code> → <code>t</code></p>                                                                                               |
| <p><code>anyrange</code> <code>&#x3C;@</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the first range contained by the second?</p><p><code>int4range(2,4) &#x3C;@ int4range(1,7)</code> → <code>t</code></p>                                                                                                            |
| <p><code>anyelement</code> <code>&#x3C;@</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the element contained in the range?</p><p><code>42 &#x3C;@ int4range(1,7)</code> → <code>f</code></p>                                                                                                                           |
| <p><code>anyrange</code> <code>&#x26;&#x26;</code> <code>anyrange</code> → <code>boolean</code></p><p>Do the ranges overlap, that is, have any elements in common?</p><p><code>int8range(3,7) &#x26;&#x26; int8range(4,12)</code> → <code>t</code></p>                                                                                |
| <p><code>anyrange</code> <code>&#x3C;&#x3C;</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the first range strictly left of the second?</p><p><code>int8range(1,10) &#x3C;&#x3C; int8range(100,110)</code> → <code>t</code></p>                                                                                         |
| <p><code>anyrange</code> <code>>></code> <code>anyrange</code> → <code>boolean</code></p><p>Is the first range strictly right of the second?</p><p><code>int8range(50,60) >> int8range(20,30)</code> → <code>t</code></p>                                                                                                             |
| <p><code>anyrange</code> <code>&#x26;&#x3C;</code> <code>anyrange</code> → <code>boolean</code></p><p>Does the first range not extend to the right of the second?</p><p><code>int8range(1,20) &#x26;&#x3C; int8range(18,20)</code> → <code>t</code></p>                                                                               |
| <p><code>anyrange</code> <code>&#x26;></code> <code>anyrange</code> → <code>boolean</code></p><p>Does the first range not extend to the left of the second?</p><p><code>int8range(7,20) &#x26;> int8range(5,10)</code> → <code>t</code></p>                                                                                           |
| <p><code>anyrange</code> <code>-|-</code> <code>anyrange</code> → <code>boolean</code></p><p>Are the ranges adjacent?</p><p><code>numrange(1.1,2.2) -|- numrange(2.2,3.3)</code> → <code>t</code></p>                                                                                                                                 |
| <p><code>anyrange</code> <code>+</code> <code>anyrange</code> → <code>anyrange</code></p><p>Computes the union of the ranges. The ranges must overlap or be adjacent, so that the union is a single range (but see <code>range_merge()</code>).</p><p><code>numrange(5,15) + numrange(10,20)</code> → <code>[5,20)</code></p>         |
| <p><code>anyrange</code> <code>*</code> <code>anyrange</code> → <code>anyrange</code></p><p>Computes the intersection of the ranges.</p><p><code>int8range(5,15) * int8range(10,20)</code> → <code>[10,15)</code></p>                                                                                                                 |
| <p><code>anyrange</code> <code>-</code> <code>anyrange</code> → <code>anyrange</code></p><p>Computes the difference of the ranges. The second range must not be contained in the first in such a way that the difference would not be a single range.</p><p><code>int8range(5,15) - int8range(10,20)</code> → <code>[5,10)</code></p> |

#### **Table 9.56. Multirange Operators**

| <p>Operator</p><p>Description</p><p>Example(s)</p>                                                                                                                                                                                                                                                                |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p><code>anymultirange</code> <code>@></code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the first multirange contain the second?</p><p><code>'{[2,4)}'::int4multirange @> '{[2,3)}'::int4multirange</code> → <code>t</code></p>                                                                |
| <p><code>anymultirange</code> <code>@></code> <code>anyrange</code> → <code>boolean</code></p><p>Does the multirange contain the range?</p><p><code>'{[2,4)}'::int4multirange @> int4range(2,3)</code> → <code>t</code></p>                                                                                       |
| <p><code>anymultirange</code> <code>@></code> <code>anyelement</code> → <code>boolean</code></p><p>Does the multirange contain the element?</p><p><code>'{[2011-01-01,2011-03-01)}'::tsmultirange @> '2011-01-10'::timestamp</code> → <code>t</code></p>                                                          |
| <p><code>anyrange</code> <code>@></code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the range contain the multirange?</p><p><code>'[2,4)'::int4range @> '{[2,3)}'::int4multirange</code> → <code>t</code></p>                                                                                   |
| <p><code>anymultirange</code> <code>&#x3C;@</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the first multirange contained by the second?</p><p><code>'{[2,4)}'::int4multirange &#x3C;@ '{[1,7)}'::int4multirange</code> → <code>t</code></p>                                                   |
| <p><code>anymultirange</code> <code>&#x3C;@</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the multirange contained by the range?</p><p><code>'{[2,4)}'::int4multirange &#x3C;@ int4range(1,7)</code> → <code>t</code></p>                                                                          |
| <p><code>anyrange</code> <code>&#x3C;@</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the range contained by the multirange?</p><p><code>int4range(2,4) &#x3C;@ '{[1,7)}'::int4multirange</code> → <code>t</code></p>                                                                          |
| <p><code>anyelement</code> <code>&#x3C;@</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the element contained by the multirange?</p><p><code>4 &#x3C;@ '{[1,7)}'::int4multirange</code> → <code>t</code></p>                                                                                   |
| <p><code>anymultirange</code> <code>&#x26;&#x26;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Do the multiranges overlap, that is, have any elements in common?</p><p><code>'{[3,7)}'::int8multirange &#x26;&#x26; '{[4,12)}'::int8multirange</code> → <code>t</code></p>                       |
| <p><code>anymultirange</code> <code>&#x26;&#x26;</code> <code>anyrange</code> → <code>boolean</code></p><p>Does the multirange overlap the range?</p><p><code>'{[3,7)}'::int8multirange &#x26;&#x26; int8range(4,12)</code> → <code>t</code></p>                                                                  |
| <p><code>anyrange</code> <code>&#x26;&#x26;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the range overlap the multirange?</p><p><code>int8range(3,7) &#x26;&#x26; '{[4,12)}'::int8multirange</code> → <code>t</code></p>                                                                  |
| <p><code>anymultirange</code> <code>&#x3C;&#x3C;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the first multirange strictly left of the second?</p><p><code>'{[1,10)}'::int8multirange &#x3C;&#x3C; '{[100,110)}'::int8multirange</code> → <code>t</code></p>                                |
| <p><code>anymultirange</code> <code>&#x3C;&#x3C;</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the multirange strictly left of the range?</p><p><code>'{[1,10)}'::int8multirange &#x3C;&#x3C; int8range(100,110)</code> → <code>t</code></p>                                                       |
| <p><code>anyrange</code> <code>&#x3C;&#x3C;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the range strictly left of the multirange?</p><p><code>int8range(1,10) &#x3C;&#x3C; '{[100,110)}'::int8multirange</code> → <code>t</code></p>                                                       |
| <p><code>anymultirange</code> <code>>></code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the first multirange strictly right of the second?</p><p><code>'{[50,60)}'::int8multirange >> '{[20,30)}'::int8multirange</code> → <code>t</code></p>                                                    |
| <p><code>anymultirange</code> <code>>></code> <code>anyrange</code> → <code>boolean</code></p><p>Is the multirange strictly right of the range?</p><p><code>'{[50,60)}'::int8multirange >> int8range(20,30)</code> → <code>t</code></p>                                                                           |
| <p><code>anyrange</code> <code>>></code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the range strictly right of the multirange?</p><p><code>int8range(50,60) >> '{[20,30)}'::int8multirange</code> → <code>t</code></p>                                                                           |
| <p><code>anymultirange</code> <code>&#x26;&#x3C;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the first multirange not extend to the right of the second?</p><p><code>'{[1,20)}'::int8multirange &#x26;&#x3C; '{[18,20)}'::int8multirange</code> → <code>t</code></p>                      |
| <p><code>anymultirange</code> <code>&#x26;&#x3C;</code> <code>anyrange</code> → <code>boolean</code></p><p>Does the multirange not extend to the right of the range?</p><p><code>'{[1,20)}'::int8multirange &#x26;&#x3C; int8range(18,20)</code> → <code>t</code></p>                                             |
| <p><code>anyrange</code> <code>&#x26;&#x3C;</code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the range not extend to the right of the multirange?</p><p><code>int8range(1,20) &#x26;&#x3C; '{[18,20)}'::int8multirange</code> → <code>t</code></p>                                             |
| <p><code>anymultirange</code> <code>&#x26;></code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the first multirange not extend to the left of the second?</p><p><code>'{[7,20)}'::int8multirange &#x26;> '{[5,10)}'::int8multirange</code> → <code>t</code></p>                                  |
| <p><code>anymultirange</code> <code>&#x26;></code> <code>anyrange</code> → <code>boolean</code></p><p>Does the multirange not extend to the left of the range?</p><p><code>'{[7,20)}'::int8multirange &#x26;> int8range(5,10)</code> → <code>t</code></p>                                                         |
| <p><code>anyrange</code> <code>&#x26;></code> <code>anymultirange</code> → <code>boolean</code></p><p>Does the range not extend to the left of the multirange?</p><p><code>int8range(7,20) &#x26;> '{[5,10)}'::int8multirange</code> → <code>t</code></p>                                                         |
| <p><code>anymultirange</code> <code>-|-</code> <code>anymultirange</code> → <code>boolean</code></p><p>Are the multiranges adjacent?</p><p><code>'{[1.1,2.2)}'::nummultirange -|- '{[2.2,3.3)}'::nummultirange</code> → <code>t</code></p>                                                                        |
| <p><code>anymultirange</code> <code>-|-</code> <code>anyrange</code> → <code>boolean</code></p><p>Is the multirange adjacent to the range?</p><p><code>'{[1.1,2.2)}'::nummultirange -|- numrange(2.2,3.3)</code> → <code>t</code></p>                                                                             |
| <p><code>anyrange</code> <code>-|-</code> <code>anymultirange</code> → <code>boolean</code></p><p>Is the range adjacent to the multirange?</p><p><code>numrange(1.1,2.2) -|- '{[2.2,3.3)}'::nummultirange</code> → <code>t</code></p>                                                                             |
| <p><code>anymultirange</code> <code>+</code> <code>anymultirange</code> → <code>anymultirange</code></p><p>Computes the union of the multiranges. The multiranges need not overlap or be adjacent.</p><p><code>'{[5,10)}'::nummultirange + '{[15,20)}'::nummultirange</code> → <code>{[5,10), [15,20)}</code></p> |
| <p><code>anymultirange</code> <code>*</code> <code>anymultirange</code> → <code>anymultirange</code></p><p>Computes the intersection of the multiranges.</p><p><code>'{[5,15)}'::int8multirange * '{[10,20)}'::int8multirange</code> → <code>{[10,15)}</code></p>                                                 |
| <p><code>anymultirange</code> <code>-</code> <code>anymultirange</code> → <code>anymultirange</code></p><p>Computes the difference of the multiranges.</p><p><code>'{[5,20)}'::int8multirange - '{[10,15)}'::int8multirange</code> → <code>{[5,10), [15,20)}</code></p>                                           |

The left-of/right-of/adjacent operators always return false when an empty range or multirange is involved; that is, an empty range is not considered to be either before or after any other range.

Elsewhere empty ranges and multiranges are treated as the additive identity: anything unioned with an empty value is itself. Anything minus an empty value is itself. An empty multirange has exactly the same points as an empty range. Every range contains the empty range. Every multirange contains as many empty ranges as you like.

The range union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented. There are separate operators for union and difference that take multirange parameters and return a multirange, and they do not fail even if their arguments are disjoint. So if you need a union or difference operation for ranges that may be disjoint, you can avoid errors by first casting your ranges to multiranges.

[Table 9.57](https://www.postgresql.org/docs/current/functions-range.html#RANGE-FUNCTIONS-TABLE) shows the functions available for use with range types. [Table 9.58](https://www.postgresql.org/docs/current/functions-range.html#MULTIRANGE-FUNCTIONS-TABLE) shows the functions available for use with multirange types.

#### **Table 9.57. Range Functions**

| <p>Function</p><p>Description</p><p>Example(s)</p>                                                                                                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <p><code>lower</code> ( <code>anyrange</code> ) → <code>anyelement</code></p><p>Extracts the lower bound of the range (<code>NULL</code> if the range is empty or the lower bound is infinite).</p><p><code>lower(numrange(1.1,2.2))</code> → <code>1.1</code></p>             |
| <p><code>upper</code> ( <code>anyrange</code> ) → <code>anyelement</code></p><p>Extracts the upper bound of the range (<code>NULL</code> if the range is empty or the upper bound is infinite).</p><p><code>upper(numrange(1.1,2.2))</code> → <code>2.2</code></p>             |
| <p><code>isempty</code> ( <code>anyrange</code> ) → <code>boolean</code></p><p>Is the range empty?</p><p><code>isempty(numrange(1.1,2.2))</code> → <code>f</code></p>                                                                                                          |
| <p><code>lower_inc</code> ( <code>anyrange</code> ) → <code>boolean</code></p><p>Is the range's lower bound inclusive?</p><p><code>lower_inc(numrange(1.1,2.2))</code> → <code>t</code></p>                                                                                    |
| <p><code>upper_inc</code> ( <code>anyrange</code> ) → <code>boolean</code></p><p>Is the range's upper bound inclusive?</p><p><code>upper_inc(numrange(1.1,2.2))</code> → <code>f</code></p>                                                                                    |
| <p><code>lower_inf</code> ( <code>anyrange</code> ) → <code>boolean</code></p><p>Is the range's lower bound infinite?</p><p><code>lower_inf('(,)'::daterange)</code> → <code>t</code></p>                                                                                      |
| <p><code>upper_inf</code> ( <code>anyrange</code> ) → <code>boolean</code></p><p>Is the range's upper bound infinite?</p><p><code>upper_inf('(,)'::daterange)</code> → <code>t</code></p>                                                                                      |
| <p><code>range_merge</code> ( <code>anyrange</code>, <code>anyrange</code> ) → <code>anyrange</code></p><p>Computes the smallest range that includes both of the given ranges.</p><p><code>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</code> → <code>[1,4)</code></p> |

#### **Table 9.58. Multirange Functions**

| <p>Function</p><p>Description</p><p>Example(s)</p>                                                                                                                                                                                                                                                 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p><code>lower</code> ( <code>anymultirange</code> ) → <code>anyelement</code></p><p>Extracts the lower bound of the multirange (<code>NULL</code> if the multirange is empty or the lower bound is infinite).</p><p><code>lower('{[1.1,2.2)}'::nummultirange)</code> → <code>1.1</code></p>       |
| <p><code>upper</code> ( <code>anymultirange</code> ) → <code>anyelement</code></p><p>Extracts the upper bound of the multirange (<code>NULL</code> if the multirange is empty or the upper bound is infinite).</p><p><code>upper('{[1.1,2.2)}'::nummultirange)</code> → <code>2.2</code></p>       |
| <p><code>isempty</code> ( <code>anymultirange</code> ) → <code>boolean</code></p><p>Is the multirange empty?</p><p><code>isempty('{[1.1,2.2)}'::nummultirange)</code> → <code>f</code></p>                                                                                                         |
| <p><code>lower_inc</code> ( <code>anymultirange</code> ) → <code>boolean</code></p><p>Is the multirange's lower bound inclusive?</p><p><code>lower_inc('{[1.1,2.2)}'::nummultirange)</code> → <code>t</code></p>                                                                                   |
| <p><code>upper_inc</code> ( <code>anymultirange</code> ) → <code>boolean</code></p><p>Is the multirange's upper bound inclusive?</p><p><code>upper_inc('{[1.1,2.2)}'::nummultirange)</code> → <code>f</code></p>                                                                                   |
| <p><code>lower_inf</code> ( <code>anymultirange</code> ) → <code>boolean</code></p><p>Is the multirange's lower bound infinite?</p><p><code>lower_inf('{(,)}'::datemultirange)</code> → <code>t</code></p>                                                                                         |
| <p><code>upper_inf</code> ( <code>anymultirange</code> ) → <code>boolean</code></p><p>Is the multirange's upper bound infinite?</p><p><code>upper_inf('{(,)}'::datemultirange)</code> → <code>t</code></p>                                                                                         |
| <p><code>range_merge</code> ( <code>anymultirange</code> ) → <code>anyrange</code></p><p>Computes the smallest range that includes the entire multirange.</p><p><code>range_merge('{[1,2), [3,4)}'::int4multirange)</code> → <code>[1,4)</code></p>                                                |
| <p><code>multirange</code> ( <code>anyrange</code> ) → <code>anymultirange</code></p><p>Returns a multirange containing just the given range.</p><p><code>multirange('[1,2)'::int4range)</code> → <code>{[1,2)}</code></p>                                                                         |
| <p><code>unnest</code> ( <code>anymultirange</code> ) → <code>setof anyrange</code></p><p>Expands a multirange into a set of ranges. The ranges are read out in storage order (ascending).</p><p><code>unnest('{[1,2), [3,4)}'::int4multirange)</code> →</p><pre><code> [1,2)
 [3,4)
</code></pre> |

The `lower_inc`, `upper_inc`, `lower_inf`, and `upper_inf` functions all return false for an empty range or multirange.

\
